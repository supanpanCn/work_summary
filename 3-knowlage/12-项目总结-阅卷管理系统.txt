（http://gitlab.uhongedu.com 账号：supanpan 密码：supan123  http://yuejuan.youjiajy.cn/login   bug网站：账号：supanpan 密码：11111111）
1-@/fileName/vueNAme.vue是在webpack中的alias中配置的相对路径
2-object.keys方法即可以遍历对象，又可以遍历数组。她的返回值将以对象的键作为成员
3-在使用vuex进行状态管理时，最好给每一个组件使用name属性标识名称
4-listen EADDRNOTAVAIL错误：（机器重启，DHCP重新分配了IP导致）
	打开cmd--运行ipconfig得到ipv4地址--修改index.js中的host即可
5-keep-alive来缓存动态组件的内容(当切回组件需要显示上一次访问状态时最有用)
6-响应路由参数的变化获取用户信息：watch或者beforeRouteUpdate
7-vuex在页面刷新后数据消失：vuex-persistedstate插件
8-下载二维码：new MouseEvent() + a标签
	var aLink = document.createElement('a')
	var event = new MouseEvent('click')
	aLink.download = '下载的二维码名称'
	a.href = 要下载的url链接目标
	a.dispatchEvent(event) 
9-生成二维码：QRCode.js
10-路由的传参
	路由跳转的方式有两种，即：router-link和编程式导航，这两种方式都会被对应的路由规则所匹配
	可以通过激活的当前路由对象在具体的组件内拿到，传递的参数将在路由对象的query或者param中保存
	如果指定了path属性，则只能通过query进行参数传递
	如果需要携带额外的参数，则可以开启路由组件传参模式
11-预览：利用iframe实现
12-计算属性
	与methods相比，它是基于缓存的，它会监听函数体，当结果发生改变时才触发视图更新（执行）
	与watch相比，它也可以用来监听数据的变化，经常二者可以做到同样的效果，可以简单的这样区分，需要在结构中使用的优先选择computed
	通过它的set方法，可以在监听到值变化时做一些动作，例如操作vuex
	通过返回一个匿名函数实现参数传递
	计算属性强调的是结果，watch监听则强调的是值的改变（如下示例：computed中，函数体只会执行两次，即满足或者步满足条件，而watch的函数体则会多次执行，只要值改变就会执行一次）
	结合使用computed和watch
		watch{
			selfKey(val){watchFnBody}
		}
		computed{
			computedFnName(){
				if(selfKey > someoneValue){computedFnBody}
			}
		}
13-mapState
	将vuex中保存的状态引入当前组件使用（vuex中保存的是被所有组件共享的数据信息）
	原生写法
		computed：{
			selfMethName(){
				return this.$store.state.willUsedVuexStateName
			}
		}
	
	mapState获取多状态的写法
		在当前组件中引入mapState辅助函数
		mapState({
			箭头函数获取(如果要使用this关键字，请使用es5的函数写法)
			    count:state=>state.count
			字符串获取
			    count:'count'
		}/[计算属性名称与state的节点名称一致时，传入字符串数组])

14-在组件中触发mutation
	this.$store.commit(mutationName,selfParamName)
	this.$store.commit({
		type:mutationName,
		paramOneName:paramOneVal,
		paramTwoName:paramTwoVal
	})
15-methods函数触发形式
	@事件触发
	{{}}触发
	v-bind绑定值中触发
16-组件通信
	父向子
		父组件使用attr/bind/module传递，子组件开启props接收
		$refs(29-$on、$emit和$refs的应用场景)
	子向父
		父组件监听来自于子组件的指定事件，子组件通过$emit向上派发
		内容分发或作用域插槽
	组件间
		vuex
		eventBus对象（$emit派发+$on监听）
		$attrs+interitAttrs+$listeners
17-some和every
	some为存在性判断
	every则为严格存在
18-reduce和map
	reduce函数会返回每一次函数执行的结果，每次函数的执行结果都会被下一次回调监听到，直到最后一次回调执行完毕后返回
	map会返回一个处理过的新数组
19-this.$set（修改对象或者数组的某个成员无法触发视图更新;类似的还有删除对象属性不触发视图更新：this.$delete）
	当使用索引改变数组（questionOne）中某一项或者修改数组长度（questionTwo）时vue无法监听，同时导致状态无法更新
	this.$set(操作的目标数组或对象,索引或键,要设置的新值)  -- questionOne（遍历方法遍历的基础是索引，因此在遍历方法如forEach或者every中进行数组成员的修改依然归属于questionOne）
	调用数组splice方法 -- questionTwo
	除了questionOne和questionTwo以外，this.$set方法还长用于更新替换数组的某一个值（类似于array.splice方法，但是由于splice是基于索引的因此会导致视图不更新）
20-filters的第一个参数是系统生成的，即竖线前，过滤器执行时传递的参数作为第2个参数开始向后传递，过滤器必须显示的return
21-深度监听（监听对象的具体某一个成员）
	watch默认无法进行深度监听对象，必须开启如下代码
		willWatchedName｛//为了提高性能，推荐使用字符串，比如“obj.a”而不是obj
			handler（newVal,oldVal）｛代码逻辑｝，
			//是否深度监听
			deep：tree，
			//立即执行handler（默认改变时才执行）
			immediate：true
		｝
	组件外使用watch时，要在组件切换时及时销毁，app.$watch调用后会返回一个unWatch方法，直接调用即可销毁
	watch还可以用来监听路由状态
	watch的监听对象的回调方法可以在methods中定义
22-判断数组的方式
	target.constructor === Array
	Array.isArray(target)
23-由于对象是地址引用，因此直接的引用会造成原数据同步改变，而vue是单向数据流对该操作敏感，因此使用深度克隆解决该问题
24-document.getElementsByClassName('classNameOne classNameTwo')
25-关于消息弹出层背景色
	要根据元素的渲染时机来获取元素并改变css样式
26-vux
	修改state必须通过mutation，访问的话有两种方式：this.$store.getters访问经过处理的状态或组件中定义computed直接获取状态
	通过this.$store.commit(mutationName,parms)更改state
	mutation是vuex的状态修改接口，在不存在异步操作时可以直接在组件中使用commit调用
	如果组件的操作是异步行为，则通过this.$dispatch触发vux中的actions，然后在actions中触发指定的mutation
	代码如下
		组件中修改vuex	
			this.$store.commit(mutationName,params)
			this.$store.dispatch(actionName,params)
		组件中获取vux
			computed(){
				selfDefinedComputedName:()=>this.$store.state.whichVuex.vuexStateName
			}
			...mapState({
				selfDefinedName:(state)=>state.pageName.stateVal
			})
			...mapState(['moudleName','atGlobleState'])
		vux中的响应
			mutations会响应到commit触发的函数，参数一是state，参数二是param
			actions会响应到dispatch触发的函数，参数一是vuex对象，参数二是param
	状态树构建
		推荐一个页面使用一个状态树（引入时通过this.$store.state.whicVuexName.stateName）
		index文件将作为主树引入其他文件		
		可以考虑定义一个mutations_types文件统一传入各文件状态树中使用，mutation的key推荐大写
27-git多人协作
	准备
	      git clone 仓库地址 （克隆仓库，默认为master主支，通常这里只有仓库文件）
	      git checkout -b  dev 创建本地开发分支
	      git checkout -b dev origin/dev  将本地分支dev与远程仓库的分支dev进行关联
	      git pull 拉取远程中最新版本的代码
	开发完成后
	      git status 查看自己改动的文件
	      git add  只添加自己改动的文件部分（注意不要使用git add.）
	      git commit -m “变动说明” 保存到本地库
	      git push origin dev 将本地的dev更新到远程仓库的dev分支
	如果其他人修改了你的同一文件，会报冲突（failed to push some refs to）
	      git pull 将远程仓库的最新代码拷贝一份
	      git status 查看冲突的文件（如果都是自己的修改那么可能查不到，要求提供合并说明时可以wq直接跳出，<<<<<<<，=======，>>>>>>>则为冲突的代码）
	      git add + git commit + git push origin dev 修改冲突后重新提交即可
28-使用this.$refs[registedName]操作dom要比原生的方法更快、性能更好（ref只在元素渲染完毕后才有机会访问、它是非响应式的，不应该用于数据绑定操作）
29-$on、$emit和$refs的应用场景（16-组件通信）
	$emit
		子组件调用父组件的方法并传递参数，需要父组件监听指定事件Name
	$on
		兄弟组件通信，就是常用的bus对象
	$refs
		父组件（子组件所在的任一嵌套父元素上）调用子组件的方法并传递参数（例如element-ui的表单验证方法）
		示例
			父组件
				父组件作用域中给某一子组件注册引用信息：ref=‘useChildEv’
				在父组件某处触发：this.$refs[useChildEv].childMethodsFn(params)
			子组件
				在methods中定义相关的方法接收来自父组件派发的事件
30-element-ui的下拉菜单的v-model/value绑定的是其数据源中每一项的value值，v-model的作用即：绑定并可赋值（可以在watch中进行深度监听验证）
31-内容分发（子传父，可以通过作用域插槽分发内容的同时传递数据）  
	子组件使用<slot name='willAcceptUserDefinedSlotName'></slot>接收
	父组件使用<element slot='selfDefineSlotName'></element>分发
32-一个变量在当前文件查询不到时，可以通过vsCode查询其定义处（在全局开发环境中配置过的可以在整个项目下直接引用）
33-定时器
	在beforeDestory中如果存在定时器要销毁，这是为了避免内存泄漏
	在created中清除定时器是为了避免定时器越来越快（setInterval按时执行，不会像setTimeOut一样等待上一个执行完毕，因此存在上一个未执行完下一个就已经开启的情况）
34-路由跳转  默认情况下路由的跳转是由路由规则中的path属性进行拦截的，当指定了name时，拦截方式就有两种：path OR name
35-vux中getter的作用
	使用场景  当某一stateKey被两组组件公用，一组需要原始值一组需要加工过滤
	需要加工处理的放置在getter中，并在组件 中通过this.$store.getters(this.$store.getters.whichVuex.gettersKeyName)获取
36-在vue中的组件上绑定原生事件(普通的html标签上不需要)
	诸如click、keydown、mouseover等原生事件，在注册时建议统一加上native修饰符
37-对象合并
	Object.assign({},waitAssignObj1,waitAssignObj2)
38-$attrs、$listeners、inheritAttrs（代码示例见“嵌套组件及其通信”）
	$attr 保持了父组件中绑定的所有数据，当当前组件开启了props时，会拦截一部分（拦截后删除）为己所用。剩下的可以通过v-bind=$attrs向子组件传递(注：只能向下传递一级)
	$listeners 保持了父组件中监听的所有事件，当父组件开启native修饰符时，会被父组件拦截（拦截后删除）。剩下的会通过v-on=$listeners向子组件传递(注：只能向下传递一级），子组件被允许直接触发
	inheritAttrs 继承父组件中没有被渲染的属性，指定为false修正“未使用的该属性将被作为元素属性渲染到当前元素上”这一默认行为
39-parseInt和parseFloat方法在将可转化的字符串转为数组时，会自动去掉首位的0
40-isNaN 可以用来限制变量类型为number类型
41-在vue项目中尽量不要进行dom操作，如果必须要做的话，应当通过$refs而不是原生的dom方法
42-监听路由跳转进行业务处理
	watch：{'$route':'methodsDefinedFnName'}
	组件的导航钩子 beforeRouteEnter和beforeRouteUpdate
43-对于需要多次使用，但是使用次数无法确定的某一项功能，以组件的形式进行组织	
44-可以使用双层定时器完成一些动画效果，如
	var upperId = setTimeout(()=>{
		var insertId = setTimeout(()=>{
			do something
		},100)
	},500)
45-使用v-text或v-html可直接动态修改元素的内容
46-switch
	switch(status){case statusOne:do sth break;case statusTwo:do sth break;default:return false}
	switch(status){case statusOne:;case statusTwo:;case statusThree:do sth;default:return false}
	switch(status){case statusOne:do sth return;case statusTwo:do sth return}
47-可以使用load事件监听某一个元素的渲染完毕
48-substr、substring、slice  只有substr是前后闭合（他们都可以基于indexOf方法从某个临界点开始截取字符）
49-img元素的x和y属性，记录的是img元素与其父元素之间的偏移距离，默认存在9像素，距离父元素的左和上越远，则x和y的值越大
50-vue中的动画可以借助transition或transiton-group组件来进行包裹实现
51-预览pdf格式的图片  vue-pdf		
52-判断对象为空  Object.values().length
53-默认情况下图片上点击后下一次事件被浏览器默认为拖拽，可以使用draggable="false"禁止该行为			
54-使用路由规则中的children+router-view实现路由的嵌套	
55-vue中的样式切换使用
	：class={active:canBeRunJs}	
	：class=“canBeRunJs”
	：class = [函数，{}]		
56-使用export default导出的，不能使用{}；使用 export flagName导出的，需要使用import {flagName} from 导入
57-相同路由地址跳转时，vue-router是不会刷新组件的，可以增加一个query参数（可以选择性配合watch重写路由对象以去除添加的query查询参数）
	watch{
		“$router":function(){}
			or
		selfDefinedNameThatWillBeChangedAtMenu:function(){}
	}
58-可以通过新建样式表的方式重置掉ui插件的默认样式
59-图片预览  v-viewer
60-对于props接收的来自于父组件的对象类型
	影响父组件状态：直接使用
	不影响：Object.assign({},propName)  或  深拷贝
61-对于图片等外部资源需要占用加载资源的文件可以使用onload监听以避免错误
62-zoom定义了一个元素的缩放比，draggable定义一个元素是否可被拖动
63-cursor：move  元素对象可被拖动	             
64-数组的严格相等：arr1.join() === arr2.join()  (成员和成员出现的位置都必须一致)
65-关闭浏览器前保存数据
	window.onbeforeunload = (event) => {
     	 	beforunload.apply(null, [event,this.cur_step]);
   	 }
66-监听页面结构 DOMNodeInserted事件
67-可以在app.vue中做一些全局的配置，如检测弹窗的出现次数
68-新窗口打开页面
	let routeData = this.$router.resolve({
		name:routerName,
		query:queryParams
	})
	window.open(routeData.href,'_blank')
69-检测用户当前浏览页：visibilitychange
	document.addEventListener("visibilitychange", () => {
      		if (!document.hidden) {
        			console.log(123)
      		}
    	})
70-检测用户扫描使用设备：window.navigator.userAgent
71-vue中进行错误拦截：Vue.config.errorHandler     返回true拦截false不拦截
72-组件内监听滚动事件
	设置根组件的的根元素样式
		overflow:scroll;（必须）
  		position:absolute;
  		top:0;
 		bottom:0;
  		left:0;
  		right:0;
	使用@scroll监听滚动行为，并触发一个methods方法
73-filters	
	页面 :  {{ val |  filtersName(vueValue) }}
	filters :  filtersName:function(val,vueValue){}
	注意：filters中拿不到this，但是可以通过参数传递vue中的值；filter可以后跟上"| anotherFilterName"形成管道
74-子元素撑开父盒子
	父盒子inline-block/float   或  父盒子只指定最小值min-width
75-禁用浏览器弹窗
	window.onbeforeunload = null
76-拖动
	//获取待移动的盒子并检测鼠标位置，通过this.$emit通知父组件处理
	let divs = document.getElementsByClassName('willMoveBox')[0]
        	ev = ev||window.event
        	this.$emit('mouse-move',{
          		x1:ev.clientX,
          		y1:ev.clientY,
         		l:divs.offsetLeft,
          		t:divs.offsetTop,
          		divs:divs
        	})
	//在父组件中监听事件触发，并执行拖动，注意盒子的定位方式（relative或absolute）
	document.onmousemove = function(ev) {
        		var ev = ev || window.event;
        		var x2 = ev.clientX;
        		var y2 = ev.clientY;
       		var x = x2 - Obj.x1;
        		var y = y2 - Obj.y1;
        		var lt = y + Obj.t;
        		var ls = x + Obj.l;
        		Obj.divs.style.top = lt + "px";
        		Obj.divs.style.left = ls + "px";
      	}
	//清除鼠标事件
      	document.onmouseup = function(ev) {
        		document.onmousemove = null;
      	}
77-禁用控制台
	//再需要的页面禁用控制台
	if (this.$route.name === "whichPage") {
        		document.onkeydown = function(ev) {
			//禁止通过F12、ctrl+shift+i
          			switch (ev.keyCode) {
            				case 16:
            				case 17:
            				case 73:
            				case 123:
              				killF12();
              				break;
          			}
          			function killF12() {
            				event.returnValue = false;
          			}
        		}
		//禁止右键检查
        		document.oncontextmenu = function(e) {
          			return false;
        		}
   	}		
78-获取鼠标对象
	let ev = new MouseEvent('click')
     自定义鼠标事件
	//定义
	let ev = document.createEvent('MouseEvents')
         	ev.initMouseEvent('mousedown', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null)
	//触发
         	document.body.dispatchEvent(ev)
	//监听
	document.onmousedown = fn
79-math.pow可以用来避免负数；Number可以用来规定只接受小数类型；parseInt可以去首位0
80-二进制和十进制转换     toString和parseInt
81-按位或		取整  1.23|0   
     按位与		奇偶   x&1==1   权限（取小）
82-解析url
	function parseURL(url) {
    		var a =  document.createElement('a');
    		a.href = url;
   		return {
        			source: url,
        			protocol: a.protocol.replace(':',''),
        			host: a.hostname,
        			port: a.port,
        			query: a.search,
        			params: (function(){
            				var ret = {},
                			seg = a.search.replace(/^\?/,'').split('&'),
                			len = seg.length, i = 0, s;
            				for (;i<len;i++) {
                				if (!seg[i]) { continue; }
                				s = seg[i].split('=');
                				ret[s[0]] = s[1];
            				}
            				return ret;
        			})(),
        			file: (a.pathname.match(/\/([^\/?#]+)$/i) || [,''])[1],
        			hash: a.hash.replace('#',''),
        			path: a.pathname.replace(/^([^\/])/,'/$1'),
        			relative: (a.href.match(/tps?:\/\/[^\/]+(.+)/) || [,''])[1],
        			segments: a.pathname.replace(/^\//,'').split('/')
    		}
	}
83-substr是截取长度、subString和slice则是按位置截取
84-break跳出循环，continue跳出当次循环，return跳出函数
85-组件方法借用
	this.$parent 获取直接父组件实例及其方法
	this.$refs 获取子组件实例及其方法
	provide函数+inject数组完成向子组件的数据或方法传递
86-强制更新
	this.$forceUpdate
87-组件内守卫
	beforeRouterEnter  this将被next函数作为参数获取
	beforeRouteUpdate 路由改变但是组件不变时触发
	beforeRouteLeave  有this实例
88-rem适配
	vscode下载cssrem修改默认为50
	npm下载flexible(iphone6设计稿750,最大支持如1024)
89-ps中调用百分比
	ctrl+r右键选择百分比
90-$attrs和$listener
	$attrs以对象形式将数据传递给孙子组件
	$listener使当前组件有能力直接监听其孙子组件
91-FileReader 读取存储在用户计算机上的文件
92-生命周期函数
	activated和deactivated专属于keep-alive包裹的组件
	errorCaptured捕获子孙组件异常
93-过滤可以用在两个地方
	插值表达式
	v-bind
94-改变v-model的监听值和回馈事件
	model:{
		prop:改变原生的value
		event:改变原生的input
	}
95-vue.$delete
	改变原生delete只抹除值的行为，同时缩小长度
96-v-text、v-html和{{}}
	v-text比{{}}少了一个闪动问题
	v-html比v-text多一个标签解析能力
97-如果标签无指令，可以使用v-pre加快编译
98-插槽（将子组件内容或数据分发给父组件处理）
	必须在子组件内部使用slot标签才能开启内容分发，否则在组件标签之间的内容不会被识别
	slot将作为占位符接收父组件的消息传递，当无消息时，显示slot本身
	如果给slot指定了name属性，那么该属性将会被父组件下的template+v-slot：slotName识别
	如果想分发数据，则需要给slot指定v-bind:别名=val,在父组件v-slot:别名=val
99-vue项目中配置跨域
	在根目录下定义env.js用来声明接口
	在webpack.dev.config.js中的plugins中定义两处
		//解决跨域
		new webpack.DefinePlugin({
      			'process.env': require('../config/dev.env')
    		})
		//将env.js打包，否则打包后无接口
		new CopyWebpackPlugin([
      			{
        				from: path.resolve(__dirname, '../static'),
        				to: config.dev.assetsSubDirectory,
        				ignore: ['.*']
      			},
      			{
        				from: path.resolve(__dirname, '../env.js'),
        				ignore: ['.*']
      			}
    		])
100-mapState接收字符串数组或函数对象
101-require和import的区别
	import只加载使用export导出的方法或者全部（按需加载）
	require相当于将加载文件转换为对象（运行时加载）
102-判断微信端
	let ua = window.navigator.userAgent.toLowerCase()
	if (ua.match(/MicroMessenger/i) == 'micromessenger') {
          		return "WeiXIN"
        	}
        	return "false"
103-require别用
	component:resolve=>require([],resolve)
104-可以在webpack.base.config.js中配置全局可用的路径
	resolve:{
		extensions:['.js','.vue','.json']
		alias:{
			'IMAGES':path.resolve(__dirname,src),
			'将在全局引用的路径别名':path.resolve方法转换
		}
	}
105-path.resolve方法
	将路径或路径片段解析为绝对路径
106-__dirname
	当前操作文件所在的目录，是一个绝对路径
107-vue加载组件的方式
	正常   import vueName from ‘src’
	懒加载   const vueName = resolve => require(['src'],resolve)
	懒加载按组   const vueName = r => require.ensure([],()=>r(require('src')),'commit')
	懒加载按组import   const  vueName = () => import('src')
108-挂载组件（addScan）的方式
	import addScan from ‘./component/AddScan’ +  components:{addScan}  //组件中挂载
	component(resolve){  //路由中挂载
		require([src],resolve)
	}
109-axios
	--拦截器
		对于频繁发送请求的借口可以限制其发送的频率
	--并发
		this.$axios.all([fn1,fn2]).then(this.$axios.spread(function(acct,perms){}))
	--取消
		切换频率过高时
		this.cancleToken = this.$axios.CancelToken.sourec()  //发送请求前获取一个source对象
		this.$axios.get(url,{
			cancelToken:this.cancleToken.token //为该次请求注册身份
		}).then(res=>console.log('success'))
		  .catch(err=>console.log('error'))
		在合适的时机取消
		this.cancleToken.cancel('这里取消后将被catch捕获到')
110-离开前提示用户
	beforeRouteLeave 
111-使用handleEvent注册事件
	let obj = {
		name:'Allev',
		handleEvent:function(e){
			switch(e.type){
				do what that you want
			}
		}
	}
	dom.addEventListener(evType,obj,false)
	
112-自定义事件
	let box = document.createEvent()
	ev.initEvent()
	box.dispatch(ev)
113-导入导出
	export let varaible / function
	import {varaibleName} from src    导入和导出的文件名称必须一致
114-单视图适合上下布局，多视图适合左右布局更加灵活